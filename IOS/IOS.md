# IOS

## issue check

# Life Cycle


# ARC





# @IBOutlet weak var

Strong 과 Weak 두가지를 사용하는데 이는 ARC와 관련이 있다. Strong의 경우에는 대상의 reference count 를 1 증가시켜 dealloc 을 막는다. 반면에 weak는 reference count 를 증가시키지 않음으로서 상호참조를 하지 않음으로서 메모리 누수를 막을 수 있다.

일반적인 상황에서는 strong을 사용해도 상관이 없다 어차피 상위객체가 dealloc 되는 순간 소유한 객체또한 dealloc을 시키려 하기 때문, 하지만 Hierarchy가 복잡해지는 경우 어떤 이유에서인지 중간에 view가 dealloc되는 경우에는 오히려 strong 사용을 권장한다.

그럼에도 불구하고 weak를 권장하는 이유는 viewcontroller의 didReceiveMemoryWarning 때문인데, 이 경우에는 main view를 dealloc 하려는 움직임이 생긴다. 만약 이때 weak가 아닌 strong으로 하게 되는 경우 reference count 가 1이하로 내려가지 않기 때문에 예상대로 해제되지가 않는다 따라서 메모리 누수가 발생할 수 있다. 

결국 강하게 서로를 잡고 있으면 (Strong) 실제로 nil인 객체이더라도 ARC가 해제를 시킬 수 없다. 이 때문에 메모리 누수가 발생할 수 있고 알맞은 상황에 strong을 사용해야한다.

> [Jingyu Jung 블로그](http://monibu1548.github.io/2018/05/03/iboutlet-strong-weak/)
> [Medium - Joyce Matos](https://medium.com/@JoyceMatos/arc-strong-and-weak-references-in-swift-f2a085a17119)


# @objc , @nonobjc

> [stack overflow](https://stackoverflow.com/questions/41036045/when-objc-and-nonobjc-write-before-method-and-variable-in-swift)

# Core Data

코어 데이터 -> 인메모리방식의 데이터 관리 프레임워크

원칙적으로 메모리에 로드된 다음에 처리가 된다. 일반적으로 영구 저장소에서 직접 처리되고, 처리를 해야하는 일부분만 메모리에 로드하고 사용하는 데이터베이스와 다른 특징이다.
인메모리 방식이지만 영구적으로 데이터를 저장할 수 있다는 점 , 검색이나 정렬과 같은 기능들을 모두 지원한다는 점 

물론 내부적으로 파일이나 SQLite 를 사용하기 때문에 앱이 종료되어도 데이터가 삭제되지 않는다.

데이터모델파일 , 엔터티 , 어트리뷰트 , 릴레이션으로 이루어져 있다.

뷰컨트롤러에서 관리 객체 컨텍스트 Managed Object Context 를 통해 필요한 메서드를 사용하면 된다. 이 객체는 코어데이터에서 만들어준다. 따라서 직접 정의해줄 필요가 없다. ( 아마도 DB를 사용할 때에는 직접 만들어줘야 한다는 것을 말하는 것 같다.)


## 이해하기 

코어데이터 : 애플리케이션에서 모델계층의 객체를 관리하는데 사용하는 프레임워크이자, 라이프 사이클이나 영속성 관리를 위한 기능을 제공하는 객체 그래프 관리자

객체지향 프로그래밍에서 말하는 객체 : 독립적이고 자체적인 생명주기를 가지면서 속성과 기능으로 이루어진 단위 구성체

레코드의 데이터가 객체화된 것을 관리되는 객체 (managed object) 라고 한다.

따라서 코어데이터가 객체 그래프의 관리를 담당한다는 것은 객체들간의 연결들을 동기화하고 관리한다 라는 뜻

따라서 코어데이터는 전체적으로 데이터베이스와 비슷한 기능을 제공하지만 , 데이터 저장에 관련된 기능을 제공하는 프레임워크이다. 또한 데이터를 객체로 다루며 객체간 관계의 일관성을 유지하는 객체 그래프 관리자로서의 특징을 가진다. 

## 코어 데이터 구조

사진 첨부

1. 관리 객체 
    - 데이터를 저장하기 위해 생성하는 인스턴스이며 모두 NSManagedObject 클래스나 하위 클래스의 인스턴스가 되어야 하며 모두 관리 객체 컨텍스트에 담겨 관리된다.
1. 관리 객체 컨텍스트 
    - 가장 핵심적인 객체 크게 두가지 역할을 담당한다.
    1. 관리 객체를 담거나 생성 삭제할 수 있다. 모든 관리 객체가 여기에 담겨서 실행된다. 쉽게말해 데이터의 CRUD 작업은 여기에서 진행이 된다. 데이터를 메모리에 로드한다는 것은 컨텍스트에 데이터를 담는다는 것이다.
    1. 영구 저장소 및 영구저장소 코디네이터에 대한 관리자이다. 즉 중간자 역할을한다.
1. 영구 저장소 코디네이터
    - 컨텍스트와 직접 데이터를 주고 받으면서 다양한 영구 저장소들의 접근을 조정하고, 해당 저장소에 대한 실제 입출력을 담당한다.
1. 관리 객체 모델 
    - DB로 치자면 테이블의 구조를 정의하는 스키마에 해당한다.
    - 엔터티 구조를 정의하는 객체
1. 영구 객체 저장소 
    - 데이터가 저장되는 저장소 환경을 의미한다.
    - 4가지 타입이 존재한다.
        1. 인메모리 저장소 타입 : 메모리 기반의 저장소를 사용하는 방식으로 앱이 종료 되었을 때 데이터가 보존되지 않는다.
        1. 플랫 바이너리 저장소 타입 : 단순 바이너리 파일 형식으로 저장
        1. XML 저장소 타입 : 전체가 저장되거나 저장되지 않는 원자성 성격을 지닌다. ios에서는 사용이 불가 ( 시간이 오래 걸림 )
        1. SQLite 데이터베이스 : 기본 선택값 , 부분적으로 저장하거나 가져온다. 원자성의 성격을 지닌 데이터 관리 타입보다 더 느리다 (찾고 저장하고 하는 과정때문에)

## 인메모리 DB

코어데이터는 인메모리 방식으로 동작하는 프레임워크이다. 사용하려는 모든 데이터는 일단 메모리에 로딩되는 과정을 거친 다음에야 비로소 사용을 할 수 있다. 영구 저장소에 데이터를 저장하는 과정은 선택적이며 변경내역을 저장소에 반영하는 커밋을 사용하는데 커밋하기 전에는 메모리에서만 존재한다. 

덕분에 빠른처리속도와 성능의 향상이 있지만 , 코드의 작성하는 방식에 따라서 성능의 저하가 생길 수 있다. 영구저장소로 SQLite 를 사용하는 경우에 디스크 io 기본 오버헤드에다가 데이터 컨버젼을 위한 오버헤드가 추가되기 때문에 많은 커밋의 경우에는 SQLite보다 느릴 수 있다.

SQLite 를 영구저장소로 선택한 경우 데이터 저장 메커니즘으로 차등 저장 메커니즘이 있다. 이는 데이터 전체를 커밋하는 것이 아니라 마지막 저장 이후 변경된 부분만 커밋을 하는 방식으로 빠르고 가볍게 처리할 수 있다.


## 코어 데이터의 한계 

필요한 부분만 사용하는 DB와 다르게 인메모리 방식이기 때문에 일단 객체를 메모리에 로딩해야 한다는 단점이 있다. 삭제의 과정 마찬가지 따라서 많은 양의 데이터를 담는것은 무리가 있다.

또한 DB에서 제공하는 unique 기능은 코어데이터에서 제공하지 않기 때문에 애플리케이션 로직에서 처리해야 한다는 단점이 있다.

또한 멀티스레드 멀티유저는 지원하지 않고 온리 싱글스레드만 지원을 한다. 즉 한번에 하나의 작업만 처리할 수 있다는 뜻 이는 멀티스레드를 사용하면 락킹 기법을 사용해야하는데 이 방식이 성능의 저하로 이루어질 수 있기 때문에 락킹기법을 제공하지 않는다.


